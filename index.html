<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Programming</title> 
    
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    <link rel='stylesheet' type='text/css' href='https://fonts.googleapis.com/css?family=Playfair+Display:700,400,900,400italic,700italic,900italic|Merriweather:400,300,700,900,300italic,400italic,700italic,900italic|Anonymous+Pro:400,700,400italic,700italic|Roboto:400,700' />
    <link rel='stylesheet' type='text/css' href='https://cdn.rawgit.com/google/code-prettify/master/styles/desert.css' />
    <link rel='stylesheet' type='text/css' href='https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css' />


<style>
body {
  margin:50px 10px;
}

#blog {
  display: block; 
  width: auto!important; 
  overflow: hidden; 
} 

a, a.named_anchor {
    text-decoration: inherit;
    font-style: inherit;
    color: inherit;
  }
  


h1 {
    letter-spacing: -0.06em;
    margin-bottom: 0.05em;
    line-height: 1em;
}

.byline {
    font: normal normal 400 1.3em;
    margin-bottom: .8em;
    letter-spacing: -0.04em;
  }

.pubdate {
    font: normal normal 400 1em;
    text-transform: uppercase;
    margin-bottom: 1em;
  }

.pubtime:before {
    font-family: 'FontAwesome';
    font-size: .8em;
    content:'\f054';
    margin: 0em .5em;
}

hr {
    border: 0;
    border-bottom: 4px double;
    height: 0.15em;
}


.topic {
    font: normal normal 900 .8em;
    text-transform: uppercase;
    margin-bottom: 1em;
  }

#article {
  font: normal normal 400 1em/2em;
  line-height: 2em;
  text-align: justify;
}

a, a:link {
    text-decoration: none;
    cursor: pointer;
    color: #1b98e0;
}  

.shade {
  background: #eee;
  padding: 0 0.2em;
}
    
h2, h3, h4, h5 { 
    font-weight: 650; 
    font-size: 1.25em; 
}


p { 
    margin-bottom:2em; 
    line-height: 2em;
}
    

/* p:first-child:first-letter { 
      font-weight: 900;
      float: left; 
      font-size: 4em; 
      line-height: 1em; 
      padding: 0em 0.1em 0em 0em;
} */

pre {
    background: #f4f4f4;
    border: 1px solid #ddd;
    border-left: 3px solid #F2957E;
    color: #666;
    page-break-inside: avoid;
    font-family: monospace;
    font-size: 15px;
    line-height: 1.6;
    margin-bottom: 1.6em;
    max-width: 100%;
    overflow: auto;
    padding: 1em 1.5em;
    display: block;
    word-wrap: break-word;
}

pre span {
  color: #339b4b;
}

.slideSample {
  width: 50%;
}

h6 {
    color: #ee856b;
}

hr {
  border: 0;
  height: 0;
  border-top: 1px solid rgba(0, 0, 0, 0.1);
  border-bottom: 1px solid rgba(255, 255, 255, 0.3);
}

@media only screen and (max-width: 768px) {
  .slideSample {
    width: 80%;
  }
}

    </style>
</head>
<body>
    


    
<div class="container">
    <div id="blog">
      <div id="title">
        <div class="pubdate">07 October 2022<hr/></div>
        <h1>A Hot Tech Interview Topic - Dynamic Programming</h1>
        <div class="byline">by Phoebe Yaheng Wu</div> 
        <!-- <div class="topic">Data</div> -->
      </div>
      
    
      
      <!-- Article text -->
      <!-- <a class="named_anchor" name="2549202418499648455"></a> -->
      <div id="article">
        <div id="content"> 
          <p>Dynamic programming is one of the hot interview topics frequently asked during technical interviews. If you are applying for a software engineering role, this blog will provide you with an overview of dynamic programming and a list of practice problems for you to familiarize yourself with.</p>
          <p>To illustrate this, imagine one day your friend comes to you with a large complicated puzzle, which in itself contains multiple smaller puzzles. You, excited to get started, pull up your sleeves and begin solving the smaller puzzles immediately. Not long into this task, you realize you have seen and solved these puzzles before. But you can't remember how you did it previously, or what the solution was. This time will be different! You decide to store the solution of each of the small puzzles you solve, in case you encounter them again. It turned out to be a great idea, as saving the results of the sub-puzzles saved you much time and unnecessary repeating of work. Because of this, you ended up solving the large complicated puzzle in a much shorter timeframe. This is the idea behind dynamic programming; avoid recalculating the same subproblems by storing intermediate results and then re-using the stored results when needed.</p>
          <p>Below, I summarized a list of dynamic programming interview questions and answers from Leetcode to help you better understand the topic. Happy coding!&#128516;</p>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/house-robber/" target="_blank">https://leetcode.com/problems/house-robber/</a></p> 
<pre>
class Solution:
  def rob(self, nums: List[int]) -> int:
      n = len(nums)
      
      dp = [0] * (n + 1)
      dp[1] = nums[0]
      
      for i in range(2, n + 1):
          dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1])
          
      return dp[n]
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/house-robber-ii/" target="_blank">https://leetcode.com/problems/house-robber-ii/</a></p> 
<pre>
class Solution:
  def rob(self, nums: List[int]) -> int:
      def helper(ls):
          n = len(ls)
          
          dp = [0] * (n + 1)
          dp[1] = ls[0]
          
          for i in range(2, n + 1):
              dp[i] = max(dp[i - 1], dp[i - 2] + ls[i - 1])
              
          return dp[n]
      
      if len(nums) == 1: return nums[0]
      return max(helper(nums[1:]), helper(nums[:-1]))
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/house-robber-iii/" target="_blank">https://leetcode.com/problems/house-robber-iii/</a></p> 
<pre>
class Solution:
  def rob(self, root: Optional[TreeNode]) -> int:
      def dfs(root):
          if not root: return [0, 0]
          
          l, r = dfs(root.left), dfs(root.right)
          
          ans = [0, 0]
          
          ans[0] = max(l[0], l[1]) + max(r[0], r[1])
          ans[1] = root.val + l[0] + r[0]
          
          return ans
      
      return max(dfs(root))
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/delete-and-earn/" target="_blank">https://leetcode.com/problems/delete-and-earn/</a></p> 
<pre>
class Solution:
  def deleteAndEarn(self, nums: List[int]) -> int:
      dp = [0] * 10001

      for x in nums:
          dp[x] += x
      
      for i in range(2, len(dp)):
          dp[i] = max(dp[i - 1], dp[i - 2] + dp[i])
      
      return dp[10000]
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/pizza-with-3n-slices/" target="_blank">https://leetcode.com/problems/pizza-with-3n-slices/</a></p> 
<pre>
class Solution:
  def maxSizeSlices(self, slices: List[int]) -> int:
      def helper(ls):
          n = len(ls)
          k = (n + 1) // 3
          
          dp = [[0] * (k + 1) for _ in range(n + 1)]
          
          for i in range(1, n + 1):
              for j in range(1, k + 1):
                  dp[i][j] = max(dp[i - 1][j], (dp[i - 2][j - 1] if i - 2 >= 0 else 0) + ls[i - 1])
                  
          return dp[n][k]
          
      return max(helper(slices[1:]), helper(slices[:-1]))
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/paint-house/" target="_blank">https://leetcode.com/problems/paint-house/</a></p> 
<pre>
class Solution:
  def minCost(self, costs: List[List[int]]) -> int:
      n = len(costs)
      dp = [[0] * 3 for _ in range(n + 1)]
      
      for i in range(1, n + 1):
          for j in range(3):
              dp[i][j] = min(dp[i - 1][(j + 1) % 3], dp[i - 1][(j + 2) % 3]) + costs[i - 1][j]
                 
      return min(dp[n])
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/paint-house-ii/" target="_blank">https://leetcode.com/problems/paint-house-ii/</a></p> 
<pre>
class Solution:
  def minCostII(self, costs: List[List[int]]) -> int:
      n, k = len(costs), len(costs[0])
      
      dp = [[inf] * k for _ in range(n + 1)]
      dp[0] = [0] * k
      
      for i in range(1, n + 1):
          for j in range(k):
              for h in range(k):
                  if j != h:
                      dp[i][j] = min(dp[i][j], dp[i - 1][h] + costs[i - 1][j])
                      
      return min(dp[n])
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/paint-fence/" target="_blank">https://leetcode.com/problems/paint-fence/</a></p> 
<pre>
class Solution:
  def numWays(self, n: int, k: int) -> int:
      same, diff = 0, k
      
      for i in range(1, n):
          same, diff = diff, (same + diff) * (k - 1)
          
      return same + diff
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/paint-house-iii/" target="_blank">https://leetcode.com/problems/paint-house-iii/</a></p> 
<pre>
class Solution:
  def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:
      dp = [[[inf]*(n+1) for _ in range(target+1)] for _ in range(m+1)]
      dp[0][0] = [0]*(n+1)
      
      for i in range(1, m+1):
          for j in range(1, target+1):
              if houses[i-1] == 0:
                  for k in range(1, n+1):
                      for prek in range(1, n+1):
                          dp[i][j][k] = min(dp[i][j][k], dp[i-1][j-(k!=prek)][prek]+cost[i-1][k-1])
                          
              else:
                  for prek in range(1, n+1):
                      dp[i][j][houses[i-1]] = min(dp[i][j][houses[i-1]], dp[i-1][j-(houses[i-1]!=prek)][prek])
                      
      ans = min(dp[m][target])
      return ans if ans != inf else -1
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a></p> 
<pre>
class Solution:
  def maxProfit(self, prices: List[int]) -> int:
      profit = 0
      buy = prices[0]
      
      for p in prices:
          buy = min(buy, p)
          profit = max(profit, p - buy)
          
      return profit
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p> 
<pre>
class Solution:
  def maxProfit(self, prices: List[int]) -> int:
      n = len(prices)
      profit = 0
      
      for i in range(1, n):
          profit += max(0, prices[i] - prices[i - 1]) 
      
      return profit
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/</a></p> 
<pre>
class Solution:
  def maxProfit(self, prices: List[int]) -> int:
      n = len(prices)
      k = 2
      
      dp = [[[0] * 2 for _ in range(k + 1)] for _ in range(n + 1)]
      
      for i in range(k + 1):
          dp[1][i][1] = -prices[0]
          
      for i in range(2, n + 1):
          for j in range(1, k + 1):
              dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i - 1])
              dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i - 1])
              
      return dp[n][k][0]
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/</a></p> 
<pre>
class Solution:
  def maxProfit(self, k: int, prices: List[int]) -> int:
      n = len(prices)
      
      dp = [[[0] * 2 for _ in range(k + 1)] for _ in range(n + 1)]
      
      for i in range(k + 1):
          dp[1][i][1] = -prices[0]
          
      for i in range(2, n + 1):
          for j in range(1, k + 1):
              dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i - 1])
              dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i - 1])
      
      return dp[n][k][0]
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p> 
<pre>
class Solution:
  def maxProfit(self, prices: List[int]) -> int:
      n = len(prices)
      
      dp = [[0] * 2 for _ in range(n + 1)]  
      dp[1][1] = -prices[0]
      
      for i in range(2, n + 1):
          dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i - 1])
          dp[i][1] = max(dp[i - 1][1], dp[i - 2][0] - prices[i - 1])
          
      return dp[n][0]
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a></p> 
<pre>
class Solution:
  def maxProfit(self, prices: List[int], fee: int) -> int:
      n = len(prices)
      
      dp = [[0] * 2 for _ in range(n + 1)]
      dp[1][1] = -prices[0]
      
      for i in range(2, n + 1):
          dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i - 1] - fee)
          dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1])
          
      return dp[n][0]
</pre>

<p class="text-center text-muted"><a href="https://leetcode.com/problems/maximum-subarray-sum-after-one-operation/" target="_blank">https://leetcode.com/problems/maximum-subarray-sum-after-one-operation/</a></p> 
<pre>
class Solution:
  def maxSumAfterOperation(self, nums: List[int]) -> int:
      n = len(nums)
      dp = [[0] * 2 for _ in range(n + 1)]
      
      dp[1][0] = nums[0]
      dp[1][1] = nums[0] ** 2
      
      ans = dp[1][1]
      
      for i in range(2, n + 1):
          dp[i][0] = max(0, dp[i - 1][0]) + nums[i - 1]
          dp[i][1] = max(dp[i - 1][1] + nums[i - 1], max(0, dp[i - 1][0]) + nums[i - 1] ** 2)
          
          ans = max(ans, dp[i][1])

      return ans
</pre> 

<p class="text-center text-muted"><a href="https://leetcode.com/problems/greatest-sum-divisible-by-three/" target="_blank">https://leetcode.com/problems/greatest-sum-divisible-by-three/</a></p> 
<pre>
class Solution:
  def maxSumDivThree(self, nums: List[int]) -> int:
      n = len(nums)
      
      dp = [[0] * 3 for _ in range(n + 1)]
      dp[0][0] = 0
      dp[0][1] = -inf
      dp[0][2] = -inf
      
      for i in range(1, n + 1):
          if nums[i - 1] % 3 == 0:
              dp[i][0] = max(dp[i - 1][0], dp[i - 1][0] + nums[i - 1])
              dp[i][1] = max(dp[i - 1][1], dp[i - 1][1] + nums[i - 1])
              dp[i][2] = max(dp[i - 1][2], dp[i - 1][2] + nums[i - 1])
          elif nums[i - 1] % 3 == 1:
              dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] + nums[i - 1])
              dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + nums[i - 1])
              dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + nums[i - 1])     
          else:
              dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + nums[i - 1])
              dp[i][1] = max(dp[i - 1][1], dp[i - 1][2] + nums[i - 1])
              dp[i][2] = max(dp[i - 1][2], dp[i - 1][0] + nums[i - 1])
      
      return dp[n][0]
</pre> 

<p class="text-center text-muted"><a href="https://leetcode.com/problems/count-ways-to-build-good-strings/" target="_blank">https://leetcode.com/problems/count-ways-to-build-good-strings/</a></p> 
<pre>
class Solution:
  def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
      MOD = 10 ** 9 + 7
      ans = 0
      dp = [0] * 100005
      dp[0] = 1

      for i in range(1, high + 1):
          if i >= zero: dp[i] = dp[i] + dp[i - zero]
          if i >= one: dp[i] = dp[i] + dp[i - one]
          if i >= low: ans = ans + dp[i]

      return ans % MOD
</pre> 

<p class="text-center text-muted"><a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank">https://leetcode.com/problems/longest-palindromic-substring/</a></p> 
<pre>
class Solution:
  def longestPalindrome(self, s: str) -> str:
      n = len(s)
      x, y = 0, 0
      dp = [[False] * n for _ in range(n)]
      
      for i in range(n):
          for j in range(i, -1, -1):
              if s[j] == s[i] and (i - j <= 2 or dp[j + 1][i - 1]):
                  dp[j][i] = True
                  if i - j > y - x:
                      x, y = j, i

      return s[x: y + 1]
</pre> 

<p class="text-center text-muted"><a href="https://leetcode.com/problems/palindromic-substrings/" target="_blank">https://leetcode.com/problems/palindromic-substrings/</a></p> 
<pre>
class Solution:
  def countSubstrings(self, s: str) -> int:
      n = len(s)
      ans = 0

      dp = [[False] * n for _ in range(n)]

      for i in range(n):
          for j in range(i, -1, -1):
              if s[j] == s[i] and (i - j <= 2 or dp[j + 1][i - 1]):
                  dp[j][i] = True
                  ans += 1

      return ans
</pre> 

<p class="text-center text-muted"><a href="https://leetcode.com/problems/palindrome-partitioning-iv/" target="_blank">https://leetcode.com/problems/palindrome-partitioning-iv/</a></p> 
<pre>
class Solution:
  def checkPartitioning(self, s: str) -> bool:
      n = len(s)
      dp = [[False] * n for _ in range(n)]

      for i in range(n):
          for j in range(i, -1, -1):
              if s[j] == s[i] and (i - j <= 2 or dp[j + 1][i - 1]):
                  dp[j][i] = True

      for i in range(1, n - 1):
          for j in range(i + 1, n):
              if dp[0][i - 1] and dp[i][j - 1] and dp[j][n - 1]:
                  return True
      return False
</pre> 

<p class="text-center text-muted"><a href="https://leetcode.com/problems/palindrome-partitioning/" target="_blank">https://leetcode.com/problems/palindrome-partitioning/</a></p> 
<pre>
class Solution:
  def partition(self, s: str) -> List[List[str]]:
      def dfs(u, path):
          if u == n:
              ans.append(path[:])
          for i in range(u,  n):
              if dp[u][i]:
                  dfs(i + 1, path + [s[u: i + 1]])

      n = len(s)
      dp = [[False] * n for _ in range(n)]

      for i in range(n):
          for j in range(i, -1, -1):
              if s[i] == s[j] and (i - j <= 2 or dp[j + 1][i - 1]):
                  dp[j][i] = True

      ans = []
      dfs(0, [])
      return ans
</pre> 

<p class="text-center text-muted"><a href="https://leetcode.com/problems/longest-palindromic-subsequence/" target="_blank">https://leetcode.com/problems/longest-palindromic-subsequence/</a></p> 
<pre>
class Solution:
  def longestPalindromeSubseq(self, s: str) -> int:
      n = len(s)
      dp = [[0] * (n + 1) for _ in range(n + 1)]

      for i in range(n + 1): dp[i][i] = 1
      for i in range(n + 1):
          for j in range(i - 1, 0, -1):
              if s[j - 1] == s[i - 1]:
                  dp[j][i] = dp[j + 1][i - 1] + 2
              else:
                  dp[j][i] = max(dp[j][i - 1], dp[j + 1][i])
      print(dp)
      return dp[1][n]    
</pre> 

</div>
      </div>
    </div>

    <!-- Footer -->
    <footer class="page-footer font-small blue pt-4">
  
      <!-- Copyright -->
      <div class="footer-copyright text-center py-3">
        
        <div id="disqus_thread"></div>
      </div>
      <!-- Copyright -->
    
    </footer>
    <!-- Footer -->
    
    </div>
    <!-- Scripts --> 

    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/prettify.js"></script>

    <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>

    <script>var pfHeaderImgUrl = '';var pfHeaderTagline = '';var pfdisableClickToDel = 0;var pfHideImages = 0;var pfImageDisplayStyle = 'right';var pfDisablePDF = 0;var pfDisableEmail = 0;var pfDisablePrint = 0;var pfCustomCSS = '';var pfBtVersion='1';(function(){var js, pf;pf = document.createElement('script');pf.type = 'text/javascript';if ('https:' === document.location.protocol){js='https://pf-cdn.printfriendly.com/ssl/main.js'}else{js='http://cdn.printfriendly.com/printfriendly.js'}pf.src=js;document.getElementsByTagName('head')[0].appendChild(pf)})();</script>



    <script>

      (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://wuyaheng.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</body>
</html>


